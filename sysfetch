#!/bin/bash

# usage
if [[ $@ =~ --help|-h|--usage|-u ]] ; then
	cat <<USAGE
|sysfetch | -f, --flag | usage |
 ------------------------------
-v, --verbose ... output all errors for debugging. use -x with bash for furter debugging
USAGE
	exit
# if verbose flag is supplied output all errors and debug
elif [[ $@ =~ --verbose|-v ]] ; then
	set -x
else
	2>/dev/null
fi

# set src path (sysfetch command breaks if ran from within the script directory
[[ -f ./sysfetch ]] && src=$(dirname "$(readlink -f "$0")") || src='/usr/share/sysfetch'

# read several variables to pull sys-based code
read kernel host kernel_rel arch os < <(uname -snrmo)

# get script based on system
if [[ $kernel_rel =~ WSL ]] ; then
	source "${src}/sys/wsl.sh"
# may be checking wrong var for Mac
elif [[ $os =~ Darwin ]] ; then
	source "${src}/sys/darwin.sh"
elif [[ $kernel = Linux ]] ; then
	source "${src}/sys/linux.sh"
# probably BSD too
elif [[ $os =~ BSD ]] ; then
	source "${src}/sys/bsd.sh"
fi

# colorize the output
write() {
for i in {0..7} ; do
	if [[ $i = $4 ]] ; then
		printf "\033[1;3${i}m%s\033[0m%s\033[1;3$((i+=1))m%s\033[0m\n" "$1" "$2" "$3"
	elif [[ $i = $3 ]] ; then
		if [[ $4 = n ]] ; then
			printf "\033[1;3${i}m%s\033[0m ~ %s\n" "$1" "$2"
		else
			printf "\033[1;3${i}m%s\033[0m ~ %s  " "$1" "$2"
		fi
	fi
done
}

# if variables not found, then don't output
[[ $user && $host ]] && write "$user" '@' "$host" 3
[[ $uptime ]] && write 'uptime' "$uptime" 5 n
[[ $kernel_rel ]] && write 'kernel' "$kernel_rel" 6
[[ $arch ]] || write 'arch' "$arch" 1 n
[[ $distro ]] && write 'distro' "$distro" 1 n
[[ $term ]] && write 'term' "$term" 2
[[ $shell ]] && write 'shell' "$shell" 5 n
[[ $dewm ]] && write 'de/wm' "$dewm" 3
[[ $theme ]] && write 'theme' "$theme" 4 n
[[ $pkgs ]] && write 'pkgs' "$pkgs" 4 n
if [[  $cur_cpu ]] ; then
	write 'cpu' "$cpu $max_cpu@$cur_cpu" 5 n
elif [[ $cpu ]] ; then
	write 'cpu' "$cpu" 5 n
fi
[[ $gpu ]] && write 'gpu' "$gpu" 6 n
[[ $gpu2 ]] && write 'gpu' "$gpu" 6 n
[[ $mobo ]] && write 'mobo' "$mobo" 1 n
[[ $disk ]] && write 'disk' "$disk $disk_model" 2 n
[[ $ram ]] && write 'ram' "${ram}" 3
[[ $swap ]] && write 'swap' "${swap}" 2 n

# pull the ascii art
source "${src}/ascii.sh"
