#!/bin/bash

# usage
[[ $@ =~ --help|-h|--usage|-u ]] && {
	cat <<USAGE
| sysfetch | -f, --flag | usage |
 -------------------------------
-v, --verbose ... output all errors for debugging. use -x with bash for furter debugging
USAGE
	exit
}

# unless verbose flag is supplied supress errors
[[ $@ =~ --verbose|-v ]] || exec 2>/dev/null

# set src path
[[ -f /usr/bin/sysfetch ]] && binPath='/usr/bin/sysfetch'
srcPath="${binPath:-${PWD}}"

# determine system with uname & pull relevant code
read kernel host kernel_rel arch os < <(uname -snrmo)

# commented-out till compatability is expanded
: ' # get script based on system
if [[ $kernel_rel =~ WSL ]] ; then
	. "${srcPath}/sys/wsl.sh"
# may be checking wrong var for Mac
elif [[ $os =~ Darwin ]] ; then
	. "${srcPath}/sys/darwin.sh"
elif [[ $kernel = Linux ]] ; then
	. "${srcPath}/sys/linux.sh"
# probably BSD too
elif [[ $os =~ BSD ]] ; then
	. "${srcPath}/sys/bsd.sh"
fi ' # source linux code
. "${srcPath}/sys/linux.sh"

# colorize the output
write() {
  if [[ $5 ]] ; then
    printf "\e[1;3%sm%s\e[0m%s\e[1;3%sm%s\e[0m$6" "$4" "$2" "$1" "$5" "$3"
  else
    printf "\e[1;3%sm%s\e[0m%s$4" "$3" "$1" "$2"
  fi
}

# if variables exist, then output
[[ $user && $host ]] && write @ "$user" "$host" 5 4 '\n'
[[ $kernel_rel ]] && write 'kernel' " ~ $kernel_rel" 2 '   '
[[ $arch ]] && write 'arch' " ~ $arch" 3 '\n'
[[ $distro ]] && write 'distro' " ~ $distro" 3 '\n'
[[ $term ]] && write 'term' " ~ $term" 4 '   '
[[ $shell ]] && write 'shell' " ~ $shell" 1 '\n'
[[ $dewm ]] && write 'de/wm' " ~ $dewm" 5 '   '
[[ $theme ]] && write 'theme' " ~ $theme" 6 '\n'
[[ $pkgs ]] && write 'pkgs' " ~ $pkgs" 6 '\n'
if [[  $cur_cpu ]] ; then	
  write 'cpu' " ~ $cpu " 1
  write @ "$max_cpu" "$cur_cpu" 4 2 'GHz\n'
elif [[ $cpu ]] ; then
	write 'cpu' " ~ $cpu" 1 '\n'
fi
[[ $gpu ]] && write 'gpu' " ~ $gpu" 2 '\n'
[[ $gpu2 ]] && write 'gpu' " ~ $gpu" 2 '\n'
[[ $mobo ]] && write 'mobo' " ~ $mobo" 3 '\n'
[[ $cur_disk ]] && write 'disk' " ~ $cur_disk/$max_disk $disk_per $disk_model" 4 '\n'
[[ $cur_ram ]] && {
  write 'ram' ' ~ ' 5
  write / "$cur_ram" "$max_ram" 2 4 'M   '
}
[[ $cur_swap ]] && {
  write 'swap' ' ~ ' 4
  write / "$cur_swap" "$max_swap" 2 4 'M\n'
}

# pull the ascii art
source "${srcPath}/ascii.sh"
